---
import BackToTop from "@components/control/BackToTop.astro";
import Footer from "@components/Footer.astro";
import Navbar from "@components/Navbar.astro";
import SideBar from "@components/widget/SideBar.astro";
import type { MarkdownHeading } from "astro";
import { Icon } from "astro-icon/components";
import ImageWrapper from "../components/misc/ImageWrapper.astro";
import TOC from "../components/widget/TOC.astro";
import { siteConfig } from "../config";
import {
	BANNER_HEIGHT,
	BANNER_HEIGHT_EXTEND,
	MAIN_PANEL_OVERLAPS_BANNER_HEIGHT,
} from "../constants/constants";
import Layout from "./Layout.astro";

interface Props {
	title?: string;
	banner?: string;
	description?: string;
	lang?: string;
	setOGTypeArticle?: boolean;
	headings?: MarkdownHeading[];
	easter?: boolean;
}

const {
	title,
	banner,
	description,
	lang,
	setOGTypeArticle,
	headings = [],
	easter = false,
} = Astro.props;
const hasBannerCredit =
	siteConfig.banner.enable && siteConfig.banner.credit.enable;
const hasBannerLink = !!siteConfig.banner.credit.url;

const mainPanelTop = siteConfig.banner.enable
	? `calc(${BANNER_HEIGHT}vh - ${MAIN_PANEL_OVERLAPS_BANNER_HEIGHT}rem)`
	: "5.5rem";
---

<Layout title={title} banner={banner} description={description} lang={lang} setOGTypeArticle={setOGTypeArticle}>
{easter ? (
    <script is:inline>if (typeof sessionStorage !== 'undefined') sessionStorage.setItem('easter', 'true');</script>
) : (
    <script is:inline>if (typeof sessionStorage !== 'undefined') sessionStorage.removeItem('easter');</script>
)}

<!-- Easter Background -->
{easter && (
    <div class="easter-bg">
        <div class="easter-nebula">
            <div class="nebula-cloud"></div>
            <div class="nebula-cloud"></div>
            <div class="nebula-cloud"></div>
        </div>
    </div>
    <div class="easter-stars" id="easter-stars"></div>
    <div class="easter-meteors" id="easter-meteors"></div>
    <div class="easter-comets" id="easter-comets"></div>
    <div class="easter-cursor-dust" id="easter-cursor-dust"></div>
    <div class="easter-clouds">
        <!-- 浮云元素 -->
        <div class="easter-cloud" style="--i:0; --x:-60vw; --h:50px; --w:260px; --d:38s; --delay:-5s;"></div>
        <div class="easter-cloud" style="--i:1; --x:-20vw; --h:40px; --w:180px; --d:42s; --delay:-10s;"></div>
        <div class="easter-cloud" style="--i:2; --x:-80vw; --h:60px; --w:300px; --d:35s; --delay:-15s;"></div>
        <div class="easter-cloud" style="--i:3; --x:-40vw; --h:45px; --w:220px; --d:45s; --delay:-20s;"></div>
        <div class="easter-cloud" style="--i:4; --x:0vw; --h:55px; --w:280px; --d:40s; --delay:-25s;"></div>
        <!-- 条状云背景 -->
        <div class="easter-cloud-bg"></div>
        <div class="easter-cloud-bg slow"></div>
    </div>
    <script is:inline>
        (function() {
            // 防止重复初始化
            if (window.easterStarsInitialized) return;
            window.easterStarsInitialized = true;

            const starContainer = document.getElementById('easter-stars');
            if (!starContainer) return;

            // 星星类型: 圆形(空字符串)、十字形、菱形、正方形、闪烁
            const starTypes = ['', 'cross', 'diamond', 'square', 'twinkle'];
            // 星星大小范围 (像素)
            const sizeRange = { min: 2, max: 8 };
            // 星星数量
            const starCount = 50;
            // 持续时间范围 (秒)
            const durationRange = { min: 4, max: 10 };
            // 间隔时间 (毫秒)
            const interval = 600;
            // 移动速度范围 (vw/秒，即视口宽度的百分比/秒)
            const speedRange = { min: 0.5, max: 2.5 };

            function random(min, max) {
                return Math.random() * (max - min) + min;
            }

            // 获取星星颜色：90%白色，10%淡黄色或青蓝色
            function getStarColor() {
                if (Math.random() < 0.9) {
                    return 'white';
                }
                // 10%概率选择特殊颜色
                const colors = [
                    '#FFFACD', // 淡黄色 LemonChiffon
                    '#F0E68C', // 淡黄 Khaki
                    '#E0FFFF', // 淡青色 LightCyan
                    '#B0E0E6', // 粉末蓝 PowderBlue
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            // 鼠标位置跟踪
            let mouseX = -1000;
            let mouseY = -1000;
            const attractRadius = 15; // 吸附半径（vw）
            const attractStrength = 0.08; // 吸附强度

            document.addEventListener('mousemove', function(e) {
                mouseX = (e.clientX / window.innerWidth) * 100;
                mouseY = (e.clientY / window.innerHeight) * 100;
            });

            document.addEventListener('mouseleave', function() {
                mouseX = -1000;
                mouseY = -1000;
            });

            function createStar() {
                const star = document.createElement('div');
                const size = random(sizeRange.min, sizeRange.max);
                const type = starTypes[Math.floor(Math.random() * starTypes.length)];
                const duration = random(durationRange.min, durationRange.max);
                const delay = random(0, 1.5);
                const starColor = getStarColor();

                // 初始位置 (vw/vh 单位)
                const startX = Math.random() * 100;
                const startY = Math.random() * 70;

                // 移动方向和速度 (使用视口宽度的百分比)
                const angle = random(0, Math.PI * 2);
                const speed = random(speedRange.min, speedRange.max);
                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;

                star.className = 'star ' + type;
                star.style.width = size + 'px';
                star.style.height = size + 'px';
                star.style.left = startX + 'vw';
                star.style.top = startY + 'vh';
                star.style.setProperty('--duration', duration + 's');
                star.style.setProperty('--delay', delay + 's');

                // 设置星星颜色
                if (starColor !== 'white') {
                    star.style.background = starColor;
                    star.style.boxShadow = `0 0 6px 2px ${starColor}`;
                }

                starContainer.appendChild(star);

                // 延迟后开始移动
                const startTime = performance.now() + delay * 1000;
                let currentX = startX;
                let currentY = startY;
                let currentVelX = velocityX;
                let currentVelY = velocityY;

                function animate(currentTime) {
                    if (currentTime < startTime) {
                        requestAnimationFrame(animate);
                        return;
                    }

                    const elapsed = (currentTime - startTime) / 1000; // 秒
                    if (elapsed >= duration) {
                        star.remove();
                        return;
                    }

                    // 计算与鼠标的距离
                    const dx = mouseX - currentX;
                    const dy = mouseY - currentY;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    // 如果在吸附半径内，向鼠标移动
                    if (distance < attractRadius && distance > 0.5) {
                        // 逐渐转向鼠标方向
                        currentVelX += dx * attractStrength * 0.1;
                        currentVelY += dy * attractStrength * 0.1;

                        // 限制最大速度
                        const maxSpeed = speed * 2;
                        const currentSpeed = Math.sqrt(currentVelX * currentVelX + currentVelY * currentVelY);
                        if (currentSpeed > maxSpeed) {
                            currentVelX = (currentVelX / currentSpeed) * maxSpeed;
                            currentVelY = (currentVelY / currentSpeed) * maxSpeed;
                        }
                    }

                    // 更新位置 (使用vw/vh单位)
                    currentX += currentVelX * 0.016; // 假设60fps，每帧移动
                    currentY += currentVelY * 0.016;

                    // 边界检查，碰到边界反弹
                    if (currentX < 0 || currentX > 100) {
                        currentVelX *= -0.8;
                        currentX = Math.max(0, Math.min(100, currentX));
                    }
                    if (currentY < 0 || currentY > 100) {
                        currentVelY *= -0.8;
                        currentY = Math.max(0, Math.min(100, currentY));
                    }

                    star.style.left = currentX + 'vw';
                    star.style.top = currentY + 'vh';

                    requestAnimationFrame(animate);
                }

                requestAnimationFrame(animate);
            }

            // 初始生成一批星星
            for (let i = 0; i < starCount; i++) {
                setTimeout(createStar, Math.random() * 4000);
            }

            // 持续生成星星
            setInterval(createStar, interval);
        })();

        // 流星效果
        (function() {
            if (window.easterMeteorsInitialized) return;
            window.easterMeteorsInitialized = true;

            const meteorContainer = document.getElementById('easter-meteors');
            if (!meteorContainer) return;

            // 流星参数范围
            const meteorInterval = 2000; // 流星间隔时间（毫秒）
            const speedRange = { min: 20, max: 40 }; // 速度 (vw/秒)
            const sizeRange = { min: 2, max: 4 }; // 流星头大小
            const trailLengthRange = { min: 40, max: 80 }; // 拖尾长度 (vw)
            const yOffsetRange = { min: 5, max: 40 }; // y偏移范围 (vh，在屏幕上半部分)
            const angleVariation = 2; // 角度变化范围 (±度)

            function random(min, max) {
                return Math.random() * (max - min) + min;
            }

            // 获取星星颜色：90%白色，10%淡黄色或青蓝色
            function getStarColor() {
                if (Math.random() < 0.9) {
                    return 'white';
                }
                const colors = [
                    '#FFFACD', '#F0E68C', '#E0FFFF', '#B0E0E6',
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            function createMeteor() {
                const meteor = document.createElement('div');
                const trail = document.createElement('div');

                const speed = random(speedRange.min, speedRange.max);
                const size = random(sizeRange.min, sizeRange.max);
                const trailLength = random(trailLengthRange.min, trailLengthRange.max);

                // 获取流星颜色
                const meteorColor = getStarColor();
                let meteorRgb, trailRgb;
                if (meteorColor === 'white') {
                    meteorRgb = '255, 255, 255';
                    trailRgb = '255, 255, 255';
                } else {
                    // 将十六进制转换为RGB
                    const hex = meteorColor.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    meteorRgb = `${r}, ${g}, ${b}`;
                    trailRgb = `${r}, ${g}, ${b}`;
                }

                // 初始位置：x从屏幕左侧外开始，y在屏幕上半部分
                const startY = random(yOffsetRange.min, yOffsetRange.max);
                const startX = -15; // 从左侧外开始

                // 移动方向：从左上到右下，添加随机角度偏移
                const baseAngle = Math.atan2(100 - startY, 120); // 基础角度
                const angleOffset = random(-angleVariation, angleVariation) * Math.PI / 180; // ±2度转换为弧度
                const angle = baseAngle + angleOffset;
                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;

                // 计算飞行持续时间（从起点到屏幕外）
                const duration = (130 - startX) / velocityX;

                // 流星头
                meteor.className = 'meteor';
                meteor.style.width = size + 'px';
                meteor.style.height = size + 'px';
                meteor.style.left = startX + 'vw';
                meteor.style.top = startY + 'vh';
                meteor.style.boxShadow = `0 0 ${size * 2}px ${size * 0.5}px rgba(${meteorRgb}, 0.8)`;
                meteor.style.animationDuration = duration + 's';

                // 拖尾 - 使用CSS transform放在流星反方向
                trail.className = 'meteor-trail';
                trail.style.width = trailLength + 'px';
                trail.style.height = (size * 0.6) + 'px';
                // 拖尾的起点是流星的反方向（angle + 180度）
                trail.style.left = startX + 'vw';
                trail.style.top = startY + 'vh';
                trail.style.transformOrigin = 'right center';
                trail.style.transform = `rotate(${angle + Math.PI}rad)`;
                trail.style.background = `linear-gradient(to left, rgba(${trailRgb},0), rgba(${trailRgb},0.9))`;
                trail.style.animationDuration = duration + 's';

                meteorContainer.appendChild(trail);
                meteorContainer.appendChild(meteor);

                const startTime = performance.now();
                let currentX = startX;
                let currentY = startY;

                function animate(currentTime) {
                    const elapsed = (currentTime - startTime) / 1000;

                    // 计算当前位置
                    currentX = startX + velocityX * elapsed;
                    currentY = startY + velocityY * elapsed;

                    // 检查是否超出屏幕范围
                    if (currentX > 120 || currentY > 120) {
                        meteor.remove();
                        trail.remove();
                        return;
                    }

                    // 更新流星头位置
                    meteor.style.left = currentX + 'vw';
                    meteor.style.top = currentY + 'vh';

                    // 拖尾位置：流星位置减去拖尾长度（在反方向上）
                    const trailOffsetX = Math.cos(angle + Math.PI) * trailLength;
                    const trailOffsetY = Math.sin(angle + Math.PI) * trailLength;
                    trail.style.left = (currentX + trailOffsetX) + 'vw';
                    trail.style.top = (currentY + trailOffsetY) + 'vh';

                    requestAnimationFrame(animate);
                }

                requestAnimationFrame(animate);
            }

            // 随机延迟后开始生成流星
            setTimeout(function() {
                createMeteor();
                // 持续生成流星
                setInterval(createMeteor, meteorInterval);
            }, random(1000, 5000));
        })();

        // 彗星效果
        (function() {
            if (window.easterCometsInitialized) return;
            window.easterCometsInitialized = true;

            const cometContainer = document.getElementById('easter-comets');
            if (!cometContainer) return;

            const cometInterval = 15000; // 彗星间隔时间（毫秒）
            const speedRange = { min: 3, max: 6 }; // 速度 (vw/秒)
            const headSizeRange = { min: 3, max: 5 }; // 彗星头大小
            const tailLengthRange = { min: 25, max: 40 }; // 尾巴长度 (vw)
            const yStartRange = { min: 5, max: 30 }; // 起始y范围

            function random(min, max) {
                return Math.random() * (max - min) + min;
            }

            // 获取星星颜色：90%白色，10%淡黄色或青蓝色
            function getStarColor() {
                if (Math.random() < 0.9) {
                    return 'white';
                }
                const colors = [
                    '#FFFACD', '#F0E68C', '#E0FFFF', '#B0E0E6',
                ];
                return colors[Math.floor(Math.random() * colors.length)];
            }

            function createComet() {
                const comet = document.createElement('div');
                const head = document.createElement('div');
                const tail = document.createElement('div');

                const speed = random(speedRange.min, speedRange.max);
                const headSize = random(headSizeRange.min, headSizeRange.max);
                const tailLength = random(tailLengthRange.min, tailLengthRange.max);

                // 获取彗星颜色
                const cometColor = getStarColor();
                let cometRgb;
                if (cometColor === 'white') {
                    cometRgb = '255, 255, 255';
                } else {
                    const hex = cometColor.replace('#', '');
                    const r = parseInt(hex.substr(0, 2), 16);
                    const g = parseInt(hex.substr(2, 2), 16);
                    const b = parseInt(hex.substr(4, 2), 16);
                    cometRgb = `${r}, ${g}, ${b}`;
                }

                const startY = random(yStartRange.min, yStartRange.max);
                const startX = -20;

                // 角度：约45度，从左上到右下划过
                const baseAngle = 45 * Math.PI / 180; // 基础角度45度
                const angleOffset = random(-10, 10) * Math.PI / 180; // ±10度变化
                const angle = baseAngle + angleOffset;

                const velocityX = Math.cos(angle) * speed;
                const velocityY = Math.sin(angle) * speed;

                const duration = (140 - startX) / velocityX;

                comet.className = 'comet';
                comet.style.opacity = '0';

                head.className = 'comet-head';
                head.style.width = headSize + 'px';
                head.style.height = headSize + 'px';
                head.style.boxShadow = `0 0 ${headSize * 3}px ${headSize}px rgba(${cometRgb}, 0.9)`;
                head.style.animation = `cometFadeInOut ${duration}s linear forwards`;

                tail.className = 'comet-tail';
                tail.style.width = tailLength + 'vw';
                tail.style.height = (headSize * 0.4) + 'px';
                // 尾巴方向与飞行方向相反
                tail.style.transform = `rotate(${angle + Math.PI}rad)`;
                tail.style.background = `linear-gradient(to right, rgba(${cometRgb}, 0.9), rgba(${cometRgb}, 0.4), transparent)`;
                tail.style.animation = `cometFadeInOut ${duration}s linear forwards`;

                comet.appendChild(tail);
                comet.appendChild(head);
                cometContainer.appendChild(comet);

                let currentX = startX;
                let currentY = startY;
                const startTime = performance.now();

                function animate(currentTime) {
                    const elapsed = (currentTime - startTime) / 1000;
                    currentX = startX + velocityX * elapsed;
                    currentY = startY + velocityY * elapsed;

                    if (currentX > 130 || currentY > 130) {
                        comet.remove();
                        return;
                    }

                    comet.style.left = currentX + 'vw';
                    comet.style.top = currentY + 'vh';
                    comet.style.opacity = '1';

                    requestAnimationFrame(animate);
                }

                requestAnimationFrame(animate);
            }

            setTimeout(function() {
                createComet();
                setInterval(createComet, cometInterval);
            }, random(2000, 8000));
        })();

        // 流星余迹效果
        (function() {
            const meteorContainer = document.getElementById('easter-meteors');
            if (!meteorContainer) return;

            const originalCreateMeteor = window.createMeteorWrapper;

            // 拦截流星创建，在流星消失时创建余迹
            const observer = new MutationObserver(function(mutations) {
                mutations.forEach(function(mutation) {
                    mutation.addedNodes.forEach(function(node) {
                        if (node.nodeType === 1 && node.classList && node.classList.contains('meteor')) {
                            const meteor = node;
                            const meteorTop = meteor.style.top;
                            const meteorLeft = meteor.style.left;

                            // 监听流星消失
                            setTimeout(function() {
                                if (meteor.parentNode) {
                                    const afterglow = document.createElement('div');
                                    afterglow.className = 'meteor-afterglow';
                                    afterglow.style.left = meteorLeft;
                                    afterglow.style.top = meteorTop;
                                    afterglow.style.width = '8px';
                                    afterglow.style.height = '8px';
                                    meteorContainer.appendChild(afterglow);

                                    setTimeout(function() {
                                        afterglow.remove();
                                    }, 1500);
                                }
                            }, 2800); // 在流星消失前创建余迹
                        }
                    });
                });
            });

            observer.observe(meteorContainer, { childList: true });
        })();

        // 鼠标跟随星尘效果
        (function() {
            const cursorDustContainer = document.getElementById('easter-cursor-dust');
            if (!cursorDustContainer) return;

            let lastX = 0;
            let lastY = 0;
            let isMoving = false;
            let moveTimeout;

            function createDust(x, y) {
                const dust = document.createElement('div');
                const size = Math.random() * 4 + 2;
                dust.className = 'cursor-dust';
                dust.style.width = size + 'px';
                dust.style.height = size + 'px';
                dust.style.left = (x - size / 2) + 'px';
                dust.style.top = (y - size / 2) + 'px';
                cursorDustContainer.appendChild(dust);

                setTimeout(function() {
                    dust.remove();
                }, 800);
            }

            document.addEventListener('mousemove', function(e) {
                const x = e.clientX;
                const y = e.clientY;

                if (!isMoving) {
                    isMoving = true;
                    createDust(x, y);
                }

                clearTimeout(moveTimeout);
                moveTimeout = setTimeout(function() {
                    isMoving = false;
                }, 100);

                // 限制产生频率
                if (Math.abs(x - lastX) > 15 || Math.abs(y - lastY) > 15) {
                    createDust(x, y);
                    lastX = x;
                    lastY = y;
                }
            });
        })();
    </script>
)}

<!-- Navbar -->
<slot slot="head" name="head"></slot>
<div id="top-row" class="z-50 pointer-events-none relative transition-all duration-700 max-w-[var(--page-width)] px-0 md:px-4 mx-auto" class:list={[""]}>
    <div id="navbar-wrapper" class="pointer-events-auto sticky top-0 transition-all">
        <Navbar></Navbar>
    </div>
</div>

<!-- Banner -->
{siteConfig.banner.enable && <div id="banner-wrapper" class={`absolute z-10 w-full transition duration-700 overflow-hidden`} style={`top: -${BANNER_HEIGHT_EXTEND}vh`}>
    <ImageWrapper id="banner" alt="Banner image of the blog" class:list={["object-cover h-full transition duration-700 opacity-0 scale-105"]}
                  src={siteConfig.banner.src} position={siteConfig.banner.position}
    >
    </ImageWrapper>
</div>}

<!-- Main content -->
<div class="absolute w-full z-30 pointer-events-none" style={`top: ${mainPanelTop}`}>
    <!-- The pointer-events-none here prevent blocking the click event of the TOC -->
    <div class="relative max-w-[var(--page-width)] mx-auto pointer-events-auto">
        <div id="main-grid" class="transition duration-700 w-full left-0 right-0 grid grid-cols-[17.5rem_auto] grid-rows-[auto_1fr_auto] lg:grid-rows-[auto]
    mx-auto gap-4 px-0 md:px-4"
        >
            <!-- Banner image credit -->
            {hasBannerCredit && <a href={siteConfig.banner.credit.url} id="banner-credit" target="_blank" rel="noopener" aria-label="Visit image source"
                                   class:list={["group onload-animation transition-all absolute flex justify-center items-center rounded-full " +
                                   "px-3 right-4 -top-[3.25rem] bg-black/60 hover:bg-black/70 h-9", {"hover:pr-9 active:bg-black/80": hasBannerLink}]}
            >
                <Icon class="text-white/75 text-[1.25rem] mr-1" name="material-symbols:copyright-outline-rounded" ></Icon>
                <div class="text-white/75 text-xs">{siteConfig.banner.credit.text}</div>
                <Icon class:list={["transition absolute text-[oklch(0.75_0.14_var(--hue))] right-4 text-[0.75rem] opacity-0",
                    {"group-hover:opacity-100": hasBannerLink}]}
                      name="fa6-solid:arrow-up-right-from-square">
                </Icon>
            </a>}


            <SideBar class="mb-4 row-start-2 row-end-3 col-span-2 lg:row-start-1 lg:row-end-2 lg:col-span-1 lg:max-w-[17.5rem] onload-animation" headings={headings}></SideBar>

            <main id="swup-container" class="transition-swup-fade col-span-2 lg:col-span-1 overflow-hidden">
                <div id="content-wrapper" class="onload-animation">
                    <!-- the overflow-hidden here prevent long text break the layout-->
                    <!-- make id different from windows.swup global property -->
                    <slot></slot>
                    <div class="footer col-span-2 onload-animation hidden lg:block">
                        <Footer></Footer>
                    </div>
                </div>
            </main>

            <div class="footer col-span-2 onload-animation block lg:hidden">
                <Footer></Footer>
            </div>
        </div>

        <BackToTop></BackToTop>
    </div>
</div>

<!-- The things that should be under the banner, only the TOC for now -->
<div class="absolute w-full z-0 hidden 2xl:block">
    <div class="relative max-w-[var(--page-width)] mx-auto">
        <!-- TOC component -->
        {siteConfig.toc.enable && <div id="toc-wrapper" class:list={["hidden lg:block transition absolute top-0 -right-[var(--toc-width)] w-[var(--toc-width)] items-center",
            {"toc-hide": siteConfig.banner.enable}]}
        >
            <div id="toc-inner-wrapper" class="fixed top-14 w-[var(--toc-width)] h-[calc(100vh_-_20rem)] overflow-y-scroll overflow-x-hidden hide-scrollbar">
                <div id="toc" class="w-full h-full transition-swup-fade ">
                    <div class="h-8 w-full"></div>
                    <TOC headings={headings}></TOC>
                    <div class="h-8 w-full"></div>
                </div>
            </div>
        </div>}

        <!-- #toc needs to exist for Swup to work normally -->
        {!siteConfig.toc.enable && <div id="toc"></div>}
    </div>
</div>
</Layout>
